[[ttt41]]

= TTT Part 41 of n {longdash} Protecting Your Secrets
include::variables.adoc[]

This installment is the first in a number of years, and while it's inspiration is very timely â€” the rise of Artificial Intelligence (AI) â€” the topic and the commands discussed are evergreen.

It's always been important to protect your secrets on the terminal. Information-stealing malware has been checking shell history files for passwords and API keys for a digital eternity, but the rise of AI-integrated terminals adds an extra urgency. When you use these kinds of tools (I love WARP), the commands you type and perhaps even the output they produce are almost certainly uploaded to an AI company's servers as *context*. At the very least, your secrets are now out of your control, but depending on the provider's terms of service, your secrets could even be added to the training data for future models!

As the old clichÃ© goes, the best time to start protecting your secrets on the command line is the first time you started using the command line, but the second-best time is now!

You need to develop the muscle memory to wince every time you type or paste a secret and see it echoed back to you, and in this instalment, we'll give you the tools you need to respond to that wince by tweaking your behaviour a little.

.Matching Podcast Episode 41
****

:mp3file: ttt-41-protecting-your-secrets/TTT_40_Protecting_Your_Secrets.mp3

Listen Along: Taming the Terminal Podcast Episode 41 +
part of https://www.podfeet.com/blog/2020/08/ccatp-650/[episode 650 of the Chit Chat Across the Pond Podcast]

// no audiocontrols in pdf
ifndef::backend-pdf,apple-books[]
audio::{url-mp3}/{mp3file}[]
endif::[]

Scan the QRcode to listen on a different device

image::qrcodes/TTT_41.png[QRcode, align='left']

You can also
{url-mp3}/{mp3file}[play/download the MP3 in your browser]
****

== Secrets?

The whole point of this instalment is to help you protect your secrets, so let's start by describing what we mean!

The term is intentionally generic because we really do mean any text that would compromise your security if it were to fall into the wrong hands. This includes passwords, API keys, private keys, and more.


== Why Protect Your Secrets on the Terminal?

It has always been true that every terminal command you type gets saved in your shell's history file. For Bash, that's `~/.bash_history`, and for ZSH it's `~/.zsh_history`. These files power the various shell history mechanisms like the up-arrow to replay recent commands, the `history` command to list previously executed commands, and Bash's reverse search triggered with kbd:[ctrl+r].

Some security tools stream these files to central logging servers for auditing purposes, and of course, stealer-type malware looks for and steals copies of these files as a matter of course. This is why you need to avoid including secrets directly in your commands.

== Guiding Principles

Let's start with the big picture â€” these are the key points to remember:

. When possible, only store secrets in your password manager or your OS's keychain.
. Avoid duplication â€” make as few copies of secrets as possible. The ideal is to keep just one copy in your password manager or OS keychain, but that's not always practical or possible. When you absolutely need to store copies elsewhere, make as few copies as possible, and record the locations in your password manager.
. Never hard-code secrets into scripts or code of any kind.
. Never include secrets directly in shell commands so they stay out of your history file!
. For interactive commands, provide secrets in real-time as and when needed.
. For automations, favour integrations with your password manager, your OS's keychain, or environment variables over configuration files.
. If you absolutely must store secrets in configuration files, use Unix file permissions to apply the _principle of least privilege_ by configuring the file ownership and permissions as restrictively as possible.

Our focus in this instalment will be on interactive commands, because that's how we most often interact with our command shells. Automations that need to run unattended are outside of the scope of this series, and often involve advanced tools or making carefully considered tradeoffs. As the clichÃ© goes, we'll leave that as an exercise for the reader ðŸ™‚

== Secure Terminal Inputs are Secure

POSIX-compliant command shells like those we use in our Linux and macOS terminals provide a secure input stream expressly for the purpose of securely entering secrets. You'll recognise these secure inputs because they silently accept your input without echoing it to the screen as you type.

Well-written terminal apps will use this secure input stream when prompting for secrets like passwords. In fact, we've already seen a few examples of this in previous installments â€” the `sudo` and `ssh` commands both use secure terminal inputs to prompt for passwords.

=== Create Your Own Secure Input Prompts with the `read` Command

It's all good and well using secure inputs when the commands you need to use support them, but what about the situations where they don't? Some commands expect to be passed secrets as command-line arguments. As you become more comfortable on the terminal, you may well start writing ever more and ever more complex scripts of your own, and you may need those scripts to prompt for secrets too.

The solution both for securely passing secrets as arguments and for securely prompting for secrets in your own scripts is the same â€” the `read` command with the `-s` (for secure) flag.

Before we look at secure inputs with `read`, let's first look at how `read` works by default.

Read's function is to prompt for input from the shell's standard input stream (STDIN), generally your keyboard, and save the entered text into a shell variable.

If you run the command without any flags or arguments, a cursor will appear on a new line, awaiting your input. Confusingly, there is no prompt, just a blinking cursor! Whatever you type will be echoed to the screen until you press kbd:[Enter] to submit the input.

The text you entered gets saved to a special shell variable named `$REPLY`. We can see this for ourselves by entering the command `read`, typing some text, hitting kbd:[Enter], and then running the command `echo "$REPLY"` to show the content of the `$REPLY` variable.

Having the text go into the `$REPLY` variable is not very useful, so you'll almost always want to specify your own variable name by passing it, without a leading `$`, as the only argument. For example, to read into a variable named `$my_text`, you would run:

[source,shell]
----
read my_text
----

Enter some text, then verify that it was indeed saved to `$my_text` by running:

[source,shell]
----
echo "$my_text"
----

This is great for reading non-secret text, but what about secrets like passwords? For that, we need the `-s` flag to trigger the terminal's secure input mode. For example, to securely read an API key into a variable named `$my_api_key`, you would use the command:

[source,shell]
----
read -s my_api_key
----

Notice that as you typed, nothing was echoed to the screen. Again, you can verify that the text was indeed saved to `$my_api_key` by running:

[source,shell]
----
echo "$my_api_key"
----

Finally, while there's little value in specifying a prompt when you're reading directly into a variable on the terminal, you really do need to provide some kind of prompt when your scripts ask for input!

Unfortunately this is one of the few places where ZSH has made a breaking change from Bash, so the syntax is compeltely different between the two shells.

Even though Macs now ship with ZSH as the default shell, Bash is still considered the de facto standard shell for scripting, so I still write all my scripts in Bash even though I use ZSH in my terminal windows.

In Bash, you simply us the `-p` flag to specify a prompt string. For example, to securely read an API key into a variable named `$my_api_key` with a prompt, you would use the command:

[source,shell]
----
# Bash only!!!
read -s -p 'API key: ' my_api_key
----

ZSH does things differently, you add the prompt to the end of the variable name argument using `?` symbol as the separator, so the example above becomes:

[source,shell]
----
# ZSH only!!!
read -s 'my_api_key?API key: '
----

Notice that in both variants I needed to include the space after the `:` as part of the prompt string.

=== How to use `read` to Keep Secrets Out of Your Shell History

The problem to be solved is that we want to pass a secret to a command as an argument, but without the secret showing up in our history file.

At the time of recording, November 2025, link:https://haveibeenpwned.com[Have I Been Pwned] (HIBP) have just released a free test API key that can be used to experiment with their powerful API before you start paying for a subscription. We're going to use this free, publicly available API key in our example. HIBP's API is a so-called REST API, so you access it over the HTTP(S) protocol. From the terminal, we can send HTTP requests using the `curl` command.

Before we do things the right way, let's first intentionally do it insecurely by directly passing the API key in our arguments to the `curl` command:

[source,shell]
----
curl --header 'hibp-api-key: 00000000000000000000000000000000' https://haveibeenpwned.com/api/v3/breachedaccount/multiple-breaches@hibp-integration-tests.com
----

This command sends a request to the HIBP API asking for a list of breaches for the test email address `multiple-breaches@hibp-integration-tests.com`, and it returns a JSON response listing the breaches:

[source,json]
----
[{"Name":"Adobe"},{"Name":"Stratfor"},{"Name":"Gawker"}]
----

Great, the command works, but what's happened to our API key? We've written it to our disk in plain text!

We can infer this has happened because when we hit the up-arrow to show previous commands, we now see that `curl` command with the API key. We can also reveal it with the `history` command (no arguments needed).

These features are all powered by our shell's history file, so let's take a look at that file directly to see the API key. 

If you're running Bash, you'll find the API key at the end of the `~/.bash_history` file:

[source,shell]
----
tail ~/.bash_history
----

And if you're running ZSH (the default on modern versions of macOS), you'll find it at the end of the `~/.zsh_history` file:

[source,shell]
----
tail ~/.zsh_history
----

Oops! Not good!

Now, let's do this the right way and contrast the resulting history file entry.

First, we'll use the `read` command to securely prompt for the API key and save it to a variable named `$hibp_api_key`:

[source,shell]
----
read -s hibp_api_key
----

Enter the API key (`00000000000000000000000000000000`) into the prompt and hit kbd:[Enter].

Note that I didn't bother to add prompt text because I'm running this directly rather than in a script.

We know that we have the API key safely stored in the `$hibp_api_key` variable without it ever being written to disk. We can verify this with the `echo` command:

[source,shell]
----
echo "$hibp_api_key"
----

Let's now use this variable to construct a safe version of the previous `curl` command:

[source,shell]
----
curl --header "hibp-api-key: $hibp_api_key" https://haveibeenpwned.com/api/v3/breachedaccount/multiple-breaches@hibp-integration-tests.com
----

Firstly, the command works just as before, returning the same JSON response, but more importantly, let's check our shell history file to see what got written there this time.

[source,shell]
----
history
----

Success! The API key was not written to disk this time!

[NOTE]
.Winodws Users can Achieve Similar Results with PowerShell
====
When you need a modern shell on Windows, you should be using PowerShell rather than the old DOS shell, and PowerShell's `Read-Host` commandlet can safely read secrets into variables like `read` can in Bash/ZSH.

In PowerShell, there are two types of strings: regular strings and secure strings. Secure strings are encrypted in memory, so they're more secure than regular strings, but not all commandlets support them. This means there are times you need to safely read into a secure string, and times you need to safely read into a regular string.

[source,powershell]
----
# Read into a regular string
$APIKey = Read-Host -MaskInput

# Read into a secure string
$SecureStringAPIKey = Read-Host -AsSecureString
----

When using this in a script, you can provide a prompt string with the `-Prompt` parameter:

[source,powershell] 
----
$APIKey = Read-Host -Prompt 'API Key' -MaskInput
$SecureStringAPIKey = Read-Host -Prompt 'API Key' -AsSecureString
----
====

== Some Helpful Tips and Tricks

We've seen how to use a variable to pass a secret using a command-line argument, but there are scripts and commands that expect to find the secrets they need in environment variables. These scripts and commands will specify the name of the environment variable to use in their documentation.

link:#ttt12[Instalment 12] is decicated to the environment, but the key difference between shell variables and environment variables is that they're available to the commands you run in your shell as well as within the shell itself.

We've already seen how to read secrets into shell variables with any arbitrary name, so the only extra step needed is to use the `export` command to promote the shell variable to an environment variable. To do that, simply pass the name of the variable as the only argument *without a preceding `$`*. 

For example, we can promote our `$hibp_api_key` shell variable to an environment variable with:

[source,shell]
----
export hibp_api_key
----

A very common kind of secret is the password used to unlock an SSH key. Remember that SSH provides a tool specifically designed to avoid the need to repeatedly enter that password â€” `ssh-agent`. We explored that in great detail in link:#ttt37[Instalment 37].

Mac users can use the `pbbaste` command to safely copy a secret from the clipboard straight into a shell variable. For example, select the following text and copy it: `some big secret!`

Now, run the command:

[source,shell]
----
my_secret=$(pbpaste)
----

The text from the clipboard is now safely stored in the `$my_secret` variable without ever being written to disk. We can prove this with:

[source,shell]
----
echo "$my_secret"
----

One nice advantage of this approach is that you can combine it with the `export` command to save the value and prompt the newly created shell variable to an environment variable in one step:

[source,shell]
----
export my_secret=$(pbpaste)
----

Finally, if you use a password manager, you may find that it offers command-line tools to make it easier to move secrets from your vaults straight into shell variables. Each password manager is different, so you'll need to check the documentation for your specific password manager to see if it has these kinds of features and how to use them.

Since I'm a long-time link:https://1password.com/[1Password] user, I know they offer a command-line tool named `op` which can be quickly installed on a Mac using link:https://brew.sh/[Homebrew]:

[source,shell]
----
brew install 1password-cli
----

You'll find the full documentation for how to connect the app to the command-line tool link:https://developer.1password.com/docs/cli/get-started/[here], but here's a quick exmaple:

[source,shell]
----
twitter_password=$(op item get 'Twitter (Personal)' --fields 'label=Password' --reveal)
----

== Final Thoughts

Remember to keep your secrets secret! If you can see a secret by hitting the up-arrow, you're doing it wrong! Stop, think about how you can avoid doing that, and start doing it the right way from then on.

It will take some time, and perhaps some faffing about, to get the hang of things, but it'll soon become second nature. Your future security is worth the effort!
